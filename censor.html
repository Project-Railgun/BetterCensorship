<!DOCTYPE html>
<!--suppress ALL -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
          integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta property="og:title" content="BetterCensorship" />
    <meta property="og:description" content="Censor and decensor images quickly." />
    <link rel="stylesheet" href="styles/icomoon.css">
    <link rel="stylesheet" href="https://necolas.github.io/normalize.css/8.0.1/normalize.css">
    <link rel="stylesheet" href="styles/styles.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js" integrity="sha512-E8QSvWZ0eCLGk4km3hxSsNmGWbLtSCSUcewDQPQWZF6pEU8GlT8a5fF32wOl1i8ftdMhssTrF/OhyGWwonTcXA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/aes.min.js" integrity="sha512-4b1zfeOuJCy8B/suCMGNcEkMcQkQ+/jQ6HlJIaYVGvg2ZydPvdp7GY0CuRVbNpSxNVFqwTAmls2ftKSkDI9vtA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="libraries/lz-string/lz-string.min.js"></script>
    <script src="libraries/FileSaver-js/FileSaver.js"></script>
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="manifest" href="site.webmanifest">
    <title>BetterCensorship</title>
</head>
<body>
<div class="pageContainer d-flex align-items-center justify-content-center">
    <div class="navLeft">
        <div class="navigationContainer ">
            <a href="/index.html">Home</a> /
            <a href="/censor.html">Censor</a> /
            <a href="/decensor.html">Decensor</a> /
            <a href="/faq.html">FAQ</a>
        </div>
    </div>
    <div class="versionRight">
        <div class="versionContainer">
            <span id="versionString">BetterCensorship vX.X.X</span><br>
            <span><a href="https://www.patreon.com/BetterRepack">Patreon</a> / <a
                    href="https://subscribestar.adult/betterrepack">SubscribeStar</a>
            </span>
        </div>
    </div>
    <div id="censorUpload" class="d-flex flex-column align-items-center" onclick="loadPage()">
        <span class="icon-folder-upload"></span>
        <span class="uploadText">Open File</span>
    </div>
    <div id="canvasContainer">

        <div class="canvas d-flex align-items-center">

            <canvas id="drawingBoard"></canvas>

            <canvas id="customImageContainer" style="display: none"></canvas>
            <canvas id="zoomContainer" style="display: none"></canvas>
        </div>

        <div class="status" id="zoom" title="Zoom lens">
            <div class="zoomHolder d-flex flex-column align-items-center">
                <canvas id="zoomImageContainer"></canvas>
            </div>
        </div>

        <div class="helperHolder" id="helperHolder" title="How do I use this tool?">
            <div class="wall-of-text">
                <p>
                    Pixelate by pressing or holding down your left mouse button.<br><br>
                    Scaling can be changed with Shift + Scrollwheel, or the slider/input below<br><br>
                    You can undo and redo your changes by pressing the buttons below<br><br>
                    You can add a password to your hidden data, to secure it from prying eyes.<br><br>
                    And then, simply press download at the end!<br><br>
                    Note: All dialog boxes can be moved by holding the title.
                </p>
            </div>
        </div>


        <div class="toolboxFloatingDialog" id="toolboxFloatingDialog" title="Toolbox">
            <div class="toolboxContainer d-flex flex-column align-items-center">

                <div class="toolboxHolder">
                    <div class="toolbox">
                        <!--                    This holds all the tools the user will add, as well as an add tool button-->
                        <ul class="d-flex align-items-center">
                            <li class="activeTool" id="tool0" onclick="switchTool(0)"><img src="assets/pixelate.png" alt="Pxl" title="Pixelate"></li>
                            <li class="" id="tool1" onclick="switchTool(1)"><img src="assets/nipcensor.png" alt="smile" title="Smiley Face"></li>
                            <li id="addTool" onclick="addTool()"><img id="addToolButton" src="assets/plus.svg" alt="add" title="Add more images!"></li>
                        </ul>
                    </div>
                </div>
                <div class="scalarHolder d-flex flex-column align-items-center">
                    <div class="slideContainer d-flex">
                        <div class="rangeHolder d-flex flex-column justify-content-center">
                            <input type="range" min="1" max="250" value="10" class="slider" id="toolScalarRange" oninput="toolScalarNumber.value = toolScalarRange.value">
                        </div>
                        <input type="number" id="toolScalarNumber" min="1" max="500" size="4" value="10" oninput="toolScalarRange.value = toolScalarNumber.value">
                    </div>
                    <label for="toolScalarRange">Scale the tool!</label>
                </div>

                <div class="zoomHandler">
                    <div class="zoomHandlerContainer d-flex align-items-center">
                        <div class="zoomHover">
                            <label for="zoomNumber" class="zoomTitle" onclick="zoomStatusFlip()">Zoom:</label>
                            <span id="zoomStatus" onclick="zoomStatusFlip()">Off</span>
                        </div>
                        <div class="numberHolder">
                            <input type="number" id="zoomNumber" min="1" max="10" size="2" value="2">
                        </div>
                    </div>
                </div>

                <div class="keyContainer d-flex flex-column align-items-center">
                    <label for="key">Add a password:&nbsp</label>
                    <input type="text" id="key" name="key">
                    <span id="keyHelpText">
                    (Empty field valid option)
                    </span>
                </div>

                <div class="filenameModifyField d-flex">
                    <label for="filenameInput">Filename:&nbsp; </label>
                    <input type="text" id="filenameInput" name="filenameInput">
                </div>

                <div class="stateControlsContainer d-flex">
                    <div class="undoButton" onclick="undoState(undoStateContainer, redoStateContainer, ctx)">
                        <span id="undoButton">
                            Undo
                        </span>
                    </div>
                    <div class="divider"></div>
                    <div class="redoButton" onclick="redoState(redoStateContainer, undoStateContainer, ctx)">
                        <span id="redoButton">
                            Redo
                        </span>
                    </div>
                </div>


                <span id="downloadButton" onclick="downloadButton();">
                    Download!
                </span>
            </div>
        </div>
    </div>
</div>
<div class="error" id="notAnImage" title="Error">Image handler crashed. Please double check that the file is actually an image no greater than 4000x3000 and 50MB in size. Press OK to reload the page</div>
<div class="error" id="resTooLarge" title="Warning">Image is too large (safe limit is 4000x3200). Usage not guaranteed. Tool may be unstable.</div>
<div class="error" id="imageContainsPayload" title="Warning">Image already contains a data payload. Proceeding further will remove any such data from the final censored image.</div>
<div class="error" id="fileTooBig" title="Error">File is too big to be processed properly (50MB Limit). Press OK to reload the page</div>
<div class="status" id="loading" title="Loading">Please wait while the image processes. Processing time depends upon image size and edited content</div>



<script>

    const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0)
    const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0)

    let _URL = window.URL || window.webkitURL;
    let globalVersion = "BetterCensorship v0.0.1"
    $("#versionString").text(globalVersion);
    let originalImageData, pixelate = true, undoStateContainer = [], redoStateContainer = [], ctx,
        boardCurrentStateHolder, globalIsDrawing = false, imageScalar = 1, toolScalar = 10,
        undoState, redoState, xOffset, yOffset, download, toolbox = [], activeTool = 0, toolCtx, toolCanvas,
        downloadButton, zoomState = false, zoomStatusFlip;

    toolbox.push({
        name: "Pixelate",
        src: "assets/pixelate.png",
    })

    toolbox.push({
        name: "Smiley Face",
        src: "assets/nipcensor.png"
    })

    let display = $("#canvasContainer").css("display");
    $("#canvasContainer").css("display", "none");

    let fileInput = $("<input type=file>");
    let toolInput = $("<input type=file>")
    let notAnImageDialog = $("#notAnImage");
    let fileTooBig = $("#fileTooBig");
    let resTooLarge = $("#resTooLarge");
    let loadingDialog = $("#loading");
    let toolboxDialog = $("#toolboxFloatingDialog");
    let helpDialog = $("#helperHolder");
    let zoomDialog = $("#zoom");
    let imageContainsPayloadDialog = $("#imageContainsPayload");

    let dialogOptions = {
        autoOpen: false,
        modal: true,
        dialogClass: "systemMessage errorDialog no-close",
        minWidth: 250,
        buttons: [
            {
                text: "OK",
                click: function () {
                    window.location.reload();
                }
            }
        ],
        position: {
            my: "center",
            at: "center",
            of: window
        }
    }

    loadingDialog.dialog({
        autoOpen: false,
        modal: true,
        dialogClass: "systemMessage no-close",
        minWidth: 250,
    })
    toolboxDialog.dialog({
        autoOpen: false,
        modal: true,
        dialogClass: "toolboxDialog no-close",
        minWidth: 0.17*vw,
        position: {
            my: "right",
            at: "right",
            of: window
        }
    })

    zoomDialog.dialog({
        autoOpen: false,
        modal: true,
        dialogClass: "zoomDialog no-close",
        minWidth: 340,
        position: {
            my: "center",
            at: "center",
            of: window
        }
    })
    helpDialog.dialog({
        autoOpen: false,
        modal: true,
        dialogClass: "helpDialog no-close",
        minWidth: 250,
        buttons: [
            {
                text: "Got it!",
                click: function () {
                    helpDialog.dialog("close");
                }
            }
        ],
        position: {
            my: "left top",
            at: "left top",
            of: window
        }
    })
    notAnImageDialog.dialog(dialogOptions);
    fileTooBig.dialog(dialogOptions);
    resTooLarge.dialog({
        autoOpen: false,
        modal: true,
        dialogClass: "systemMessage errorDialog no-close",
        minWidth: 250,
        buttons: [
            {
                text: "Got it!",
                click: function () {
                    resTooLarge.dialog("close");
                    $("body").css('background-color', "white");
                }
            }
        ],
        position: {
            my: "center",
            at: "center",
            of: window
        }
    });

    imageContainsPayloadDialog.dialog({
        autoOpen: false,
        modal: true,
        dialogClass: "systemMessage errorDialog no-close",
        minWidth: 250,
        buttons: [
            {
                text: "Got it!",
                click: function () {
                    imageContainsPayloadDialog.dialog("close");
                    $("body").css('background-color', "white");
                }
            }
        ],
        position: {
            my: "center",
            at: "center",
            of: window
        }
    });

    let loadPage = function () {
        fileInput.click();
        return false;
    }
    let addTool = function () {
        toolInput.click();
        return false;
    }

    toolInput.change(function () {

        let file;
        if ((file = this.files[0])) {

            let img = new Image();
            toolCanvas = $("#customImageContainer")[0];
            toolCtx = toolCanvas.getContext("2d");

            img.onload = function () {
                toolCanvas.height = this.height;
                toolCanvas.width = this.width;
                toolCtx.drawImage(img, 0, 0);
                toolbox.push({
                    name: file.name,
                    src: _URL.createObjectURL(file)
                })
                pixelate = false;
                $(`#tool${activeTool}`).removeClass("activeTool");
                let toolIndex = toolbox.length-1
                activeTool = toolIndex
                toolScalar = 1;
                $(`<li class='activeTool' id="tool${toolIndex}" onclick="switchTool(${toolIndex})">
                        <img title="${toolbox[toolIndex].name}" src="${toolbox[toolIndex].src}" alt="${toolbox[toolIndex].name}">
                    </li>`).insertBefore($("#addTool"));
                $("#toolScalarRange").attr("max", "4");
                $("#toolScalarRange").attr("min", "0.1");
                $("#toolScalarRange").attr("step", "0.1");

            }
            img.onerror = function () {
                alert("File not an image");
            }
            img.src = _URL.createObjectURL(file);
        }
    })

    let switchTool = function (toolIndex) {
        if (toolIndex === 0) {
            pixelate = true;
            toolScalar = 10;
            $(`#tool${activeTool}`).removeClass("activeTool");
            activeTool = toolIndex;
            $(`#tool${activeTool}`).addClass("activeTool");
            $("#toolScalarRange").attr("max", "250");
            $("#toolScalarRange").attr("min", "1");
            $("#toolScalarRange").attr("step", "1");
            return;
        }

        let img = new Image();
        toolCanvas = $("#customImageContainer")[0];
        toolCtx = toolCanvas.getContext("2d");

        img.onload = function () {
            toolCanvas.height = this.height;
            toolCanvas.width = this.width;
            toolCtx.drawImage(img, 0, 0);
            pixelate = false;
            $(`#tool${activeTool}`).removeClass("activeTool");
            activeTool = toolIndex;
            toolScalar = 1;
            $(`#tool${activeTool}`).addClass("activeTool");
            $("#toolScalarRange").attr("max", "4");
            $("#toolScalarRange").attr("min", "0.1");
            $("#toolScalarRange").attr("step", "0.1");
        }

        img.onerror = function () {
            alert("Something went wrong. Please submit a bug report along with any image files you were using.")
        }

        img.src = toolbox[toolIndex].src
    }

    fileInput.change(function () {
        let file, canvas;
        if ((file = this.files[0])) {
            if (file.size >= 52428800) {
                fileTooBig.dialog("open");
                $("body").css('background-color', "grey");
                return
            }
            let img = new Image();

            canvas = $("#drawingBoard")[0];
            ctx = canvas.getContext("2d");
            img.onload = function () {

                $("#canvasContainer").css("display", display)
                $("#censorUpload").attr('style', 'display: none !important');
                canvas.height = this.height;
                canvas.width = this.width;
                if (this.height > (document.documentElement.clientHeight/1.1)) {
                    imageScalar = this.height/(document.documentElement.clientHeight/1.1);
                    $("#drawingBoard").css("height", `${this.height/imageScalar}px`)
                    $("#drawingBoard").css("width", `${this.width/imageScalar}px`)
                } else if (this.width > (document.documentElement.clientWidth/1.1)) {
                    imageScalar = this.width/(document.documentElement.clientWidth/1.1);
                    $("#drawingBoard").css("height", `${this.height/imageScalar}px`)
                    $("#drawingBoard").css("width", `${this.width/imageScalar}px`)
                }
                ctx.drawImage(img, 0, 0);
                originalImageData = ctx.getImageData(0, 0, this.width, this.height);
                undoStateContainer.push(originalImageData);
                boardCurrentStateHolder = originalImageData;
                $("#filenameInput").val(file.name.split(".")[0] + "_censored.png")
                toolboxDialog.dialog("open");
                helpDialog.dialog("open");

                let reader = new FileReader();

                reader.onload = function (){
                    try {
                        let view = new Uint8Array(reader.result);
                        let list = metadata.splitChunk(Uint8ToString(view));
                        if (list[list.length-2].type !== "IDAT") {
                            imageContainsPayloadDialog.dialog("open");
                            $("body").css('background-color', "grey");
                        }
                    } catch {
                        //Do absolutely nothing, ignore all errors and proceed to image drawing.
                    }
                }

                reader.readAsArrayBuffer(file);

                if ((img.height * img.width > (4000*3200))) {
                    resTooLarge.dialog("open");
                    $("body").css('background-color', "grey");
                }

            }
            img.onerror = function () {
                notAnImageDialog.dialog("open");
                $("body").css('background-color', "grey");

            }
            img.src = _URL.createObjectURL(file);

            downloadButton = function () {
                loadingDialog.dialog("open");
                setTimeout(()=>{
                    download();
                }, 1)
            }

            download = function () {
                let downloadImageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height).data;
                let originalData = originalImageData.data;
                let chunkSize = 250;
                let chunkItems;
                let payload = {
                    chunkSize: chunkSize,
                    chunkCount: 0,
                    items:[]
                }
                for (let i = 0; i<=originalData.length; i+=chunkSize) {
                    if (i+chunkSize>originalData.length) {
                        chunkItems = originalData.length - i
                    } else {
                        chunkItems = chunkSize;
                    }
                    for (let j = 0; j<chunkItems; j++) {
                        if (originalData[i+j] !== downloadImageData[i+j]) {
                            let intArray = new Uint8Array(originalData.slice(i, i+chunkSize));
                            let packedArray = pack(intArray);
                            payload.items.push(
                                {
                                    chunkIndex: i,
                                    arrayString: packedArray
                                }
                            )
                            break;
                        }
                    }
                    // Loop Over all 100 items
                    // If difference in any pixel, copy the 100 chunk into metadata, then break out back into earlier loop. Do for all array items.
                }
                payload.chunkCount = payload.items.length;
                let payloadString = JSON.stringify(payload);

                let compressedPayload = LZString.compress(payloadString);

                let CryptoJSCompatibleFormat = CryptoJS.enc.Utf16.parse(compressedPayload);
                let passphrase = $("#key").val();
                let payloadChunk = CryptoJS.AES.encrypt(CryptoJSCompatibleFormat, passphrase).toString();

                canvas.toBlob(blob => {
                    let reader = new FileReader();
                    reader.onload = function () {
                        let view = new Uint8Array(reader.result);
                        let list = metadata.splitChunk(Uint8ToString(view));
                        let iend = list.pop();
                        let signature = metadata.createChunk("tEXt", "Version"+String.fromCharCode(0x00)+globalVersion);
                        let payload = metadata.createChunk("tEXt", "Payload"+String.fromCharCode(0x00)+payloadChunk);
                        let encryption = metadata.createChunk("tEXt", "Encrypted"+String.fromCharCode(0x00)+((passphrase.length!==0 ? "Yes": "No")))
                        list.push(signature);
                        list.push(encryption);
                        list.push(payload);
                        list.push(iend);
                        let newPNG = metadata.joinChunk(list);
                        let b = convertBinaryStringToUint8Array(newPNG);
                        let blob = new Blob([b.buffer], {type: "image/png"});
                        let filename = $("#filenameInput").val();
                        saveAs(blob, filename);
                        loadingDialog.dialog("close");
                    }
                    reader.readAsArrayBuffer(blob);
                })
            }

            $("#drawingBoard").mousedown(function () {
                boardCurrentStateHolder = ctx.getImageData(0, 0, canvas.width, canvas.height);
                globalIsDrawing = true;
            })

            $("body").mouseup(function () {
                if (globalIsDrawing) {
                    undoStateContainer.push(boardCurrentStateHolder);
                    globalIsDrawing = false;
                }
            })



            $("#drawingBoard").mousemove(function (e){

                let offsetX, offsetY;

                if (!globalIsDrawing) {
                    ctx.putImageData(boardCurrentStateHolder, 0, 0);
                }

                if (e.offsetX && e.offsetY) {
                    offsetX = e.offsetX;
                    offsetY = e.offsetY;
                    xOffset = offsetX;
                    yOffset = offsetY;
                } else {
                    offsetX = xOffset;
                    offsetY = yOffset;
                }

                if (pixelate) {
                    let sideLength = parseInt(Math.sqrt(((ctx.canvas.height*ctx.canvas.width)*(0.0001*toolScalar))))
                    let x = (parseInt((offsetX*imageScalar)/sideLength)*sideLength);
                    let y = (parseInt((offsetY*imageScalar)/sideLength)*sideLength);
                    let rgba = [0, 0, 0, 0];
                    let data = ctx.getImageData(x, y, sideLength, sideLength).data;

                    for (let i = 0; i<data.length; i+=4){
                        rgba[0] += data[i]
                        rgba[1] += data[i+1]
                        rgba[2] += data[i+2]
                        rgba[3] += data[i+3]
                    }

                    let alpha = rgba[3];
                    rgba = rgba.map(i=>Math.floor(i/(sideLength**2)));
                    ctx.fillStyle = `rgba(${rgba[0]}, ${rgba[1]}, ${rgba[2]}, ${(alpha)/255})`;
                    ctx.fillRect(x, y, sideLength, sideLength);
                } else {

                    let x = (offsetX*imageScalar);
                    let y = (offsetY*imageScalar);
                    let iconWidth = toolCanvas.width;
                    let iconHeight = toolCanvas.height;
                    if (toolScalar === 0) {
                        toolScalar = -0.1
                    }
                    ctx.drawImage(toolCanvas, x-((iconWidth*toolScalar)/2), y-((iconHeight*toolScalar)/2), iconWidth*toolScalar, iconHeight*toolScalar)
                }

                if (zoomState) {
                    let x = (offsetX*imageScalar);
                    let y = (offsetY*imageScalar)
                    let scalar = $("#zoomNumber").val();

                    zoomLens(ctx.getImageData(x-(300/scalar/2), y-(300/scalar/2), x+(300/scalar/2), y+(300/scalar/2)), 300/scalar, scalar);
                }
                if (globalIsDrawing) {
                    boardCurrentStateHolder = ctx.getImageData(0, 0, canvas.width, canvas.height);
                }

            })

            let zoomLens = function (canvasData, sideLength, scalar) {
                zoomDialog.dialog("open");
                let zoomHolderCanvas = $("#zoomContainer")[0];
                let zoomHolderCtx = zoomHolderCanvas.getContext("2d");
                zoomHolderCanvas.height = sideLength;
                zoomHolderCanvas.width = sideLength;
                zoomHolderCtx.putImageData(canvasData, 0, 0);


                let zoomImageCanvas = $("#zoomImageContainer")[0];
                let zoomImageCtx = zoomImageCanvas.getContext("2d");
                zoomImageCanvas.height = sideLength*scalar;
                zoomImageCanvas.width = sideLength*scalar;
                zoomImageCtx.drawImage(zoomHolderCanvas, 0, 0, zoomHolderCanvas.width*scalar, zoomHolderCanvas.height*scalar);
                zoomImageCtx.strokeStyle = "#00FFFF";
                zoomImageCtx.beginPath();
                zoomImageCtx.moveTo(sideLength*scalar/2, 0);
                zoomImageCtx.lineTo(sideLength*scalar/2, sideLength*scalar);
                zoomImageCtx.closePath();
                zoomImageCtx.stroke();
                zoomImageCtx.beginPath();
                zoomImageCtx.moveTo(0, sideLength*scalar/2);
                zoomImageCtx.lineTo(sideLength*scalar, sideLength*scalar/2);
                zoomImageCtx.closePath();
                zoomImageCtx.stroke();
            }

            zoomStatusFlip = function () {
                let zoomStatus = $("#zoomStatus");
                if (zoomStatus.text() === "Off") {
                    zoomState = true;
                    zoomDialog.dialog("open");
                    zoomStatus.text("On");
                    zoomStatus.addClass("toggled");
                } else {
                    zoomState = false;
                    zoomDialog.dialog("close");
                    zoomStatus.text("Off");
                    zoomStatus.removeClass("toggled");
                }
            }

            $("#drawingBoard").mouseout(function () {
                if (!globalIsDrawing) {
                    ctx.putImageData(boardCurrentStateHolder, 0, 0);
                }
            })

            $("#drawingBoard").bind('wheel', function (e) {
                if (!(e.shiftKey)) {
                    return;
                }

                if (pixelate) {
                    if (e.originalEvent.wheelDelta/120>0) {
                        toolScalar = toolScalar + 5;
                    } else {
                        toolScalar = toolScalar - 5;
                    }

                    if (toolScalar<1) {
                        toolScalar = 1;
                    }
                } else {
                    if (e.originalEvent.wheelDelta/120>0) {
                        toolScalar = toolScalar + 0.1;
                    } else {
                        toolScalar = toolScalar - 0.1;
                    }
                }
                let rounded = Math.round(toolScalar * 100) / 100
                $("#toolScalarNumber").val(rounded);
                $("#toolScalarRange").val(rounded);

                $("#drawingBoard")[0].dispatchEvent(new Event('mousemove'));
            })

            $("#toolScalarRange").change(function (){
                toolScalar= parseFloat($("#toolScalarRange").val());
            })
            $("#toolScalarNumber").change(function (){
                toolScalar = parseFloat($("#toolScalarNumber").val());
            })

            undoState = function (undoStateContainer, redoStateContainer, ctx) {
                if (undoStateContainer.length>1) {
                    let state = undoStateContainer.pop();
                    boardCurrentStateHolder = undoStateContainer[undoStateContainer.length-1]
                    ctx.putImageData(boardCurrentStateHolder, 0, 0);
                    redoStateContainer.push(state);
                }
            }

            redoState = function (redoStateContainer, undoStateContainer, ctx) {
                if (redoStateContainer.length > 0) {
                    let state = redoStateContainer.pop();
                    boardCurrentStateHolder = state;
                    ctx.putImageData(boardCurrentStateHolder, 0, 0);
                    undoStateContainer.push(state);
                }
            }

        }
    })
</script>

<script>
    //Foreign Code

    function pack(bytes) {
        var chars = [];
        for(var i = 0, n = bytes.length; i < n;) {
            chars.push(((bytes[i++] & 0xff) << 8) | (bytes[i++] & 0xff));
        }
        return String.fromCharCode.apply(null, chars);
    }

    let metadata = {}
    metadata.PNG_SIG = String.fromCharCode(0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a);

    function convertBinaryStringToUint8Array(bStr) {
        var len = bStr.length, u8_array = new Uint8Array(len);
        for (var i = 0; i < len; i++) {
            u8_array[i] = bStr.charCodeAt(i);
        }
        return u8_array;
    }

    function Uint8ToString(u8a){
        var CHUNK_SZ = 0x8000;
        var c = [];
        for (var i=0; i < u8a.length; i+=CHUNK_SZ) {
            c.push(String.fromCharCode.apply(null, u8a.subarray(i, i+CHUNK_SZ)));
        }
        return c.join("");
    }

    metadata.isPNG = function (s) {
        var sig = s.substr(0, 8);
        return (sig === metadata.PNG_SIG);
    };

    metadata.splitChunk= function (s) {
        // read signature
        var sig = s.substr(0, 8);
        if (!metadata.isPNG(sig)) return false;
        s = s.substr(8); // chomp sig
        var chunklist = [];
        // read chunk list
        while (s !== '') {
            var chunk = {};
            // read chunk size
            var size = stoi(s.substr(0, 4));
            if (size < 0) {
                // If the size is negative, the data is likely corrupt, but we'll let
                // the caller decide if any of the returned chunks are usable.
                // We'll move forward in the file with the minimum chunk length (12 bytes).
                size = 0;
            }
            var buf = s.substr(0, size + 12);
            s = s.substr(size + 12); // delete this chunk
            // read chunk data
            chunk.size = size;
            chunk.type = buf.substr(4, 4);
            chunk.data = buf.substr(8, size);
            chunk.crc  = stoi(buf.substr(8 + size, 4));
            // add chunk
            chunklist.push(chunk);
        }
        return chunklist;
    };

    metadata.joinChunk = function (chunklist) {
        var pf = metadata.PNG_SIG;
        for (var i in chunklist) {
            var chunk = chunklist[i];
            // check size
            // chunk.size = chunk.data.length;
            // calc crc
            // var crc_v = crc32(chunk.type + chunk.data);
            //
            var buf = "";
            buf += itos(chunk.size, 4);
            buf += chunk.type;
            buf += chunk.data;
            buf += itos(chunk.crc, 4);

            pf += buf;
        }
        return pf;
    };

    metadata.createChunk = function (type, data) {
        var c = {};
        c.type = type;
        c.data = data;
        c.size = data.length;
        c.crc  = crc32(type+data);
        return c;
    };

    metadata.itos = itos;
    function itos(v, size) {
        var a = [];
        var t = size - 1;
        // noinspection ES6ConvertVarToLetConst
        while (t >= 0) {
            var c = v & 0xFF;
            a[t--] = c;
            v = v >> 8;
        }
        a = a.map(function(v) {
            return String.fromCharCode(v);
        });
        return a.join('');
    }

    metadata.stoi = stoi;
    function stoi(s) {
        var v = 0;
        for (var i = 0; i < s.length; i++) {
            var c = s.charCodeAt(i);
            v = (v << 8) | (c & 0xFF);
        }
        return v;
    }

    function crc32(str) {
        var hexTable = [0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D]
        var crc = 0 ^ (-1);
        for (var i = 0; i < str.length; i++) {
            crc = (crc >>> 8) ^ hexTable[(crc ^ str.charCodeAt(i)) & 0xFF];
        }
        return (crc ^ (-1)) >>> 0;
    }

</script>

</body>
</html>